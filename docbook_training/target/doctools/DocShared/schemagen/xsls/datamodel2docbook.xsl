<?xml version="1.0" ?>
<!DOCTYPE xsl:stylesheet[
<!ENTITY do.not.edit "	<xsl:comment>
	  This file is automatically generated. Do not edit!
	</xsl:comment>">
]>
<xsl:stylesheet version="2.0" 
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	xmlns:bj="http://motive.com/techpubs/datamodel" 
	xmlns:lookup="http://www.broadjump.com/lookup"
	xmlns:db="http://docbook.org/ns/docbook"
	xmlns="http://docbook.org/ns/docbook" 
	xmlns:xi="http://www.w3.org/2001/XInclude"
	xmlns:xlink="http://www.w3.org/1999/xlink"
	exclude-result-prefixes="lookup bj db ">

	<!-- 
  -->

	<xsl:output indent="yes"/>

	<!--
  This stylesheet converts a datamodel file
  to a Docbook part, chapter, or section, based on property settings.  

Category divisions for tables and views are defined in a separate file categories.xsl; 
this file is not found in the doctools source; it is to be created in the 
project's /schema folder, and then ant copies it into target/DocShared/schemagen/xsls
when you do a rebuild, so that it is reachable by THIS xsl. 
	-->




	<!-- Declare parameters for the root element and subelement of the generated schema,
		 to be filled by an ant property when this xsl is called
		 The values below are thus just default values.
		 
		 This allows you to change items in build.properties to control whether you generate
		 a part that contains chapters
		 a chapter that contains sections
		 an appendix that contains sections
	-->
	<xsl:param name="schema.root.element">chapter</xsl:param>
	<xsl:param name="schema.rh.keyword">NONE</xsl:param>
	<xsl:param name="schema.table.include">NONE</xsl:param> <!-- JCBG-1953 -->
	
	<!-- determine the schema.subelement programmatically (not being set as before)-->
	<xsl:variable name="schema.subelement">
		<xsl:choose>
			<xsl:when test="normalize-space($schema.root.element)='part'">chapter</xsl:when> <!-- for JCBG-1494, added a $ in front of the schema.root.element name here; before, it lacked that and thus was not actually fetching the var value for the comparison ... AaronDaMommio, 6/26/14-->
			<xsl:otherwise>section</xsl:otherwise>
		</xsl:choose></xsl:variable>

	<!-- Parameter for the xml:id value of the root element of the generated file. For example, if you're making an appendix, this will be its xml:id.
	     This one is also set in build.properties. -->
	<xsl:param name="schema.id">default.database.reference</xsl:param>

	<!-- Parameter for the index type default value. -->
	<xsl:param name="schema.index.type"/>

   <!-- global variables 
   
   -->

	<!-- make a list of all table names in all categories categories, as one big searchable string 
	
	we're making the list like this:
	
	TABLE1,
	TABLE2,
	etc...
	so that we can search for '<tablename>,' and prevent finding substrings. For example if you had 2 tables DEVICE and DEVICEPROPS, we 
	don't want to find DEVICE in the list, so we search on 'DEVICE,'.
	
	-->
	<xsl:variable name="CATTABLES">
		<!-- for each subject area, write out every name, separately -->
		<xsl:for-each select="document('categories.xsl')//lookup:subject-area">
          <xsl:for-each select="tokenize(.,',')">
<xsl:value-of select="normalize-space(.)"/>,<xsl:text>
</xsl:text>
			</xsl:for-each>
		</xsl:for-each>
		
	</xsl:variable>

  <!-- unused tables/views -->
	<xsl:variable name="UNUSED">
		
	
		
		<!-- drop a log msg if there are ANY unused tables... -->
		<xsl:if test="//bj:table[not(contains($CATTABLES,concat(normalize-space(@name),',')))]">
			<xsl:message>
==============================
UNUSED TABLES/VIEWS: See the end of the generated schema file for a list of
tables/views that are not listed in any categories. The list will 
be in a comment.
==============================
				<xsl:text>
        	
       </xsl:text> </xsl:message>			
		</xsl:if>

		<unused>
			<!-- filter on the normalized name + comma, so that we don't false-find a substring, such as if two tables
				were named DEVICE and DEVICEPROPS -->
			<xsl:for-each select="//bj:table[not(contains($CATTABLES,concat(normalize-space(@name),',')))]">
				 <xsl:apply-templates select="." mode="list"/>
<!-- disabled: listing the unused tables at end of log...
				<xsl:message><xsl:value-of select="@name"/></xsl:message> -->
			</xsl:for-each>
		</unused>
	</xsl:variable> 
	

	<xsl:variable name="CATTABLESXML">
		<!-- precursor var to generate list of table names as nodes; using this in DUPES-->
		<db:items>
		<xsl:for-each select="tokenize($CATTABLES,',')">
			<xsl:if test="normalize-space(.) !=''">
				<db:item><xsl:value-of select="."/></db:item>
			</xsl:if>
			
		</xsl:for-each>
		</db:items>
	</xsl:variable>

<xsl:variable name="DUPES">
	<!-- test for dupe table names in cat list; this var's value is not used, I'm just using
	the fact that a variable can run over the whole input document to trigger behavior-->
	
	<!-- iterate over actual table names in the data model, since being listed falsely 
		twice is not a catastrophic error-->
	<xsl:for-each select="$CATTABLESXML//db:item">
		<xsl:variable name="NAME" select="normalize-space(.)"/>
		<xsl:variable name="COUNT" select="count($CATTABLESXML//db:item[normalize-space(.)=$NAME])"/>
		<xsl:if test="$COUNT > 0">
			[<xsl:value-of select="$NAME"/>] = <xsl:value-of select="$COUNT"/><xsl:text>
</xsl:text>		</xsl:if>

		<xsl:if test="$COUNT > 1">
			<xsl:message terminate="yes">
=====================================
DUPLICATE NAME ERROR: the name <xsl:value-of select="."/>
is listed <xsl:value-of select="$COUNT"/> times in categories.xsl. 
This would cause duplicate ID errors. 
Correct this mistake and rebuild.
=====================================</xsl:message>
			
		</xsl:if>
	</xsl:for-each>
</xsl:variable>


   	<!-- list of all the views in the datamodel -->
	<xsl:variable name="VIEWS">
		<views>
		 <xsl:apply-templates select="//bj:table[@view = 'yes']" mode="list"/>
		</views>
	</xsl:variable> 
	
<xsl:template match="bj:table" mode="list">
  <!-- This is used to list item names (table or view) to insert in variables  -->
<xsl:text>
</xsl:text><item><xsl:value-of select="@name"/></item>
   </xsl:template>

  <!-- $HAVEVIEWS:
  	Determines whether we have any views in our categories, and stores that determination.
  	Tests only the first listed item in any category, assumes the rest are the same.
  	
  	Used to decide whether we need to subdivide the output into 'Tables' and 'Views' or can skip 
  	that subdivision. 
  	
  	(Does NOT indicate whether there are views in the datamodel, but rather whether we have listed 
  	any views in our categories, and therefore whether we want to publish views.)

  -->

	
	<xsl:variable name="HAVEVIEWS1" >
		<!-- this is a precursor to making a simple HAVEVIEWS var
			I couldn't figure out a way to do this with just one expression, since I 
			needed to iterate a comparison
			the below will produce 1 yes for each category that starts with a view 
			then HAVEVIEWS will simplify that to a single yes or no value
		-->
		<xsl:for-each select="//bj:table[@view = 'yes']">
			<!-- compare each view name with the set of first items listed in categories
				the expression below adds a trailing comma to each category list and then takes the substring before comma;
				this ensures we get a match in the case where only one item is in the category and thus there IS no comma-->
			<xsl:if 
			test="document('categories.xsl')//lookup:subject-area[normalize-space(substring-before(concat(.,','),',')) = current()/@name]">yes(<xsl:value-of select="@name"/>)</xsl:if>
			</xsl:for-each>
	</xsl:variable>	
	
	<xsl:variable name="HAVEVIEWS" >
		<xsl:choose>
			<xsl:when test="substring(normalize-space($HAVEVIEWS1),1,3) = 'yes'">yes</xsl:when>
			<xsl:otherwise>no</xsl:otherwise>
		</xsl:choose>
		
	</xsl:variable>	
	
	


	<xsl:template match="/">
		<xsl:apply-templates/>
	
		<!-- Write out some debug info	at end of file	-->	
		<xsl:comment>
List of views in this datamodel:
<xsl:value-of select="$VIEWS"/>
<xsl:if test="normalize-space($VIEWS)=''">NO VIEWS FOUND</xsl:if>

Value of HAVEVIEWS = <xsl:value-of select="$HAVEVIEWS"/> 
<xsl:if test="$HAVEVIEWS='no'"> (no views were specified in categories, so no 'Tables' and 'Views' subsections will be output.)</xsl:if>			
<xsl:if test="$HAVEVIEWS='yes'"> (Some views were specified in categories, so 'Tables' and 'Views' subsections will be output.)</xsl:if>			

<!--
List of all tables listed in categories: 

<xsl:value-of select="$CATTABLES"/>  
-->
Unused tables/views (not listed in any category):
<xsl:value-of select="$UNUSED"/>
			
list of tables as nodes... but only the first two
<xsl:value-of select="$CATTABLESXML//db:item[1]"/>
<xsl:value-of select="$CATTABLESXML//db:item[2]"/>
			
dupes....
<xsl:value-of select="$DUPES"/>
			
index into cattablesxml... 
<!--
$CATTABLESXML//item[contains(.,'V')] = <xsl:value-of select="$CATTABLESXML//item[contains(.,'V')]"/>
$CATTABLESXML//item[1]=<xsl:value-of select="$CATTABLESXML//item[1]"/>
$CATTABLESXML//db:item[1]=<xsl:value-of select="$CATTABLESXML//db:item[1]"/>
$CATTABLESXML//db:item[contains(.,'V')] = <xsl:value-of select="$CATTABLESXML//db:item[contains(.,'V')]"/> -->
count($CATTABLESXML//db:item[. ='MARKEDFLOWS')] = <xsl:value-of select="count($CATTABLESXML//db:item[. ='MARKEDFLOWS'])"/>
count($CATTABLESXML//db:item[. ='MARKEDFLOWS')] = <xsl:value-of select="count($CATTABLESXML//db:item[. ='MARKEDFLOWS'])"/>
		
</xsl:comment>

		
	</xsl:template>





	<xsl:template match="bj:section"> &do.not.edit; <section>
			<xsl:attribute name="xml:id">
				<xsl:value-of select="@id"/>
			</xsl:attribute>
			<title><xsl:value-of select="bj:title"/></title>
			<xsl:apply-templates/>
		</section>
	</xsl:template>

<!-- storing current doc for reference -->
	<xsl:variable name="current.doc">
		<xsl:copy-of select="/"/>
	</xsl:variable>

	<xsl:template match="bj:subsystem">

		<xsl:if test="not(@security) or @security != 'internal'"> &do.not.edit; 
			<xsl:element name="{normalize-space($schema.root.element)}">
				<xsl:namespace name="db">http://docbook.org/ns/docbook</xsl:namespace>
				<xsl:namespace name="xi">http://www.w3.org/2001/XInclude</xsl:namespace>
				<xsl:namespace name="xlink">http://www.w3.org/1999/xlink</xsl:namespace>
			
				<xsl:attribute name="version">5.0-extension BroadBook-2.0</xsl:attribute>
				<xsl:attribute name="xml:id"><xsl:value-of select="$schema.id"/></xsl:attribute>
				<info>
						<title><xsl:value-of select="bj:title"/></title>
				<xsl:if test="not($schema.rh.keyword = 'NONE')">  
					<xsl:message>Setting a Release Highlights keyword of <xsl:value-of select="$schema.rh.keyword"/> on the root element.</xsl:message>
					<keywordset>
						<keyword role="rh"><xsl:value-of select="$schema.rh.keyword"/></keyword>
					</keywordset>
				</xsl:if> 
				</info>
				<xsl:apply-templates select="bj:description"/> 
			
			<xsl:for-each select="db:section">
				<!-- This section template is for sections 	in a bj:subsystem, which are used to subdivide the content of the top-level
					description. 
					
					The weird part here is: when writing subdivided content inside the bj:subsystem/bj:description, you must use db:sections. But when 
					the datamodel is converted to docbook, if your root element is part, then the subdivisions need to be chapters,
					so we have to construct the subdivision using xsl:element. -->

					<xsl:element name="{$schema.subelement}">
						<xsl:copy-of select="@*"/>
						<xsl:copy-of select="./*"/>
					</xsl:element>
			</xsl:for-each>
			
			
			<!-- Now, process the categories (lookup:subject-area) elements in the external file categories.xsl, using those
				as a way to lookup the appropriate tables/views. -->
			
			
			      <!-- here we are grouping on 'table or view' by looking up the value of the @view of the first
			      	table listed in each group. We find the first table by getting the substring-before the first comma.  	
			      	
			      	Since @view is absent for tables, really we are talking about values of
			      	'yes' or null. Therefore I did the group-adjacent expression with ='yes' at the end, so that it is a boolean 
			      	... and so we're really grouping on true or false. That way both values are the same type. I can't group on yes-or-null because
			      	those are not both boolean, they're a string and a boolean.
			      -->
			<xsl:for-each-group
				select="document('categories.xsl')//lookup:subject-area"
				group-adjacent="$current.doc//bj:table[@name= normalize-space(substring-before(concat(current(),','),','))]/@view = 'yes'">
				
				<xsl:sort order="descending"/>
				
<!--- did not work:
	normalize-space(substring-before(concat(..,','),',')) = $current.doc//bj:table[@view]/@name"
				$current.doc//bj:table[@name= normalize-space(substring-before(concat($tables,','),','))]/@view = 'yes'
				
				boolean($current.doc//bj:table[@name= normalize-space(substring-before(concat(current(),','),','))]/@view)"  -->
				
			
<!-- group wrapper and title; this is conditional b/c if we don't have
any views, we won't need a Tables/Views subdivision -->
<xsl:choose>
<xsl:when test="$HAVEVIEWS = 'yes'">
<xsl:comment>Grouping key value =  <xsl:value-of select="current-grouping-key()"/></xsl:comment><xsl:text>
</xsl:text>

<section><title>
				<xsl:choose>
					<!-- since current grouping key is either true=view or false=not view...-->
					<xsl:when test="current-grouping-key()">Views</xsl:when>
					<xsl:otherwise>Tables</xsl:otherwise>
				</xsl:choose></title>
			<xsl:for-each select="current-group()" >
				
				<!-- current-group() produces the CONTENTS of the categories, not the nodes themselves, so it seems that the intent
				was that you should put the code to process those contents here. But I already have that in a template below, so I'm just
				calling it by name. Also, allows me to use same code in the otherwise below.-->
				<xsl:call-template name="category"/>
			</xsl:for-each>
		
		</section>
			
	</xsl:when> 
    <xsl:otherwise>  <!-- otherwise, we don't need the Type or Views subdivision, so just do the current-grouping stuff-->
    	<xsl:for-each select="current-group()">
    		<xsl:call-template name="category"/>
    	</xsl:for-each>
    	
    </xsl:otherwise>	
</xsl:choose>

</xsl:for-each-group>
				
			</xsl:element><!-- end wrapper for schema.root.element -->
			<xsl:text>

      </xsl:text>
		</xsl:if>
	</xsl:template>
	
	<!-- test template: change the template name below to 'category' and change the real category 
		template to something like category1, and you can build stuff and just see 
		category names, to test grouping/sorting -->
	
	<xsl:template name="categoryxxx">
<xsl:text>
</xsl:text><xsl:value-of select="@name"/>
	</xsl:template>


    <!-- this template process lookup:subject-areas, and generates the category header and then processes the tables/views
    	named in the category 
    
    	We're now only calling this template by NAME
    
    -->
	<xsl:template match="lookup:subject-area" name="category">
		
		<!-- store table list in a var for later use when we change the context-->
		<xsl:variable name="tables" select="."/>
		<!-- store category name for this subject-area in a var for later use when we change the context-->
		<xsl:variable name="catname" select="@name"/>

        <!-- determine whether this is a table category or a view one 
        Here we check only the first item and assume all others are the same. If they aren't all the same, it's an error, one we should
        have caught earlier. We don't check it here.
        -->
		<xsl:variable name="type">
			<xsl:choose>
				<xsl:when test="$current.doc//bj:table[@name= normalize-space(substring-before(concat($tables,','),','))]/@view = 'yes'">VIEW</xsl:when>
				<xsl:otherwise>TABLE</xsl:otherwise>
			</xsl:choose>
		</xsl:variable>

        <!-- Now we need to output a category wrapper element, UNLESS we have only 1 category of this type (views or tables)
        
        To do that we need a choose structure, where in case1 we don't generate the wrapper, and 
        in case 2 we do
        	
        -->
		
		<xsl:choose>
			<xsl:when test="count(current-group())= 1">
		
<xsl:comment>(No category header because there is only ONE category of this type. This category contains [<xsl:value-of select="$type"/>] objects (assumed based on 1st listed object).)</xsl:comment><xsl:text>
</xsl:text>
				<xsl:call-template name="tokenize-category-list">
					<xsl:with-param name="catname"></xsl:with-param>
				</xsl:call-template>
				
			</xsl:when>
			<xsl:otherwise>
				<xsl:element name="{$schema.subelement}">
					<title>
						<xsl:value-of select="@name"/>
					</title>
					<xsl:comment>This category contains [<xsl:value-of select="$type"/>] objects (assumed based on 1st listed object).</xsl:comment><xsl:text>
</xsl:text>				
					<xsl:call-template name="tokenize-category-list">
				<xsl:with-param name="catname"></xsl:with-param>
			</xsl:call-template>
				</xsl:element>	</xsl:otherwise>
		</xsl:choose>


	</xsl:template>

<xsl:template name="tokenize-category-list">
	<xsl:param name="catname"/>
     <!-- Go through the list of tables for a category, and apply templates... -->
			<xsl:for-each select="tokenize(., ',')">
				<!-- Throw an error if we don't find the token name in the set of table names -->
				<xsl:if test="not($current.doc//bj:table[@name= normalize-space(current())]/@name)">
					<xsl:message terminate="no">===================
WARNING: No table/view named <xsl:value-of select="normalize-space(.)"/> found. 
Your categories.xsl file lists it in the <xsl:value-of select="$catname"/> category,
but I can't find it in your datamodel file.
===================	</xsl:message>
</xsl:if>
				<xsl:apply-templates select="$current.doc//bj:table[@name= normalize-space(current())]"/>
			</xsl:for-each>

	</xsl:template>
	
	
	<xsl:template match="bj:table[@audience = 'dev']"/>

	<xsl:template match="bj:table[not(@audience = 'dev')]">
		<xsl:param name="subsystem" select="../bj:title"/>
		<xsl:param name="table" select="@name"/> &do.not.edit; <section>
			<xsl:attribute name="xml:id">
				<xsl:value-of select="$table"/>
			</xsl:attribute>
			<xsl:if
				test="contains(@name, 'STG_') and 
		substring-before(normalize-space(@name), 'STG_') = ''">
				<xsl:attribute name="security">writeronly</xsl:attribute>
			</xsl:if>
			<title>
				<xsl:value-of select="@name"/>
			</title>
			<xsl:if test="not($schema.table.include = 'NONE')">  <!-- JCBG-1953 -->
			  <xsl:message>Inserting a table include: <xsl:value-of select="$schema.table.include"/></xsl:message>
			  <xsl:variable name="file" select="$schema.table.include"/>
			  <xi:include href="{$file}"/>
			</xsl:if> 

			<xsl:apply-templates select="bj:description"/>
			<indexterm>
				<xsl:if test="$schema.index.type">
					<!-- Output a type attrib only if schema.index.type is set -->
					<xsl:attribute name="type"><xsl:value-of select="$schema.index.type"
						/></xsl:attribute>
				</xsl:if>
				<primary><xsl:value-of select="$subsystem"/></primary>
				<secondary localize="no"><xsl:value-of select="$table"/></secondary>
			</indexterm>
			<!--indexterm>
	  <primary><xsl:value-of select="$table"/></primary>
	</indexterm-->
			<xsl:apply-templates select="bj:uks"/> &do.not.edit; <xsl:choose>
				<xsl:when test="@added and not(normalize-space(@added) = '')">
					<para>
						<emphasis role="bold">Added:&#160;</emphasis>
						<xsl:value-of select="@added"/>
						<indexterm>
							<xsl:if test="$schema.index.type">
								<!-- Output a type attrib only if schema.index.type is set -->
								<xsl:attribute name="type"><xsl:value-of select="$schema.index.type"
									/></xsl:attribute>
							</xsl:if>
							<primary>Added in <xsl:value-of select="@added"/></primary>
							<secondary localize="no"><xsl:value-of select="$table"/></secondary>
						</indexterm>
					</para>
				</xsl:when>
				<xsl:when test="@removed">
					<para>
						<emphasis role="bold">Removed:&#160;</emphasis>
						<xsl:value-of select="@removed"/>
						<indexterm>
							<xsl:if test="$schema.index.type">
								<!-- Output a type attrib only if schema.index.type is set -->
								<xsl:attribute name="type"><xsl:value-of select="$schema.index.type"
									/></xsl:attribute>
							</xsl:if>
							<primary>Added in <xsl:value-of select="@removed"/></primary>
							<secondary localize="no"><xsl:value-of select="$table"/></secondary>
						</indexterm>
					</para>
				</xsl:when>
				<xsl:when test="@deprecated">
					<para>
						<emphasis role="bold">Deprecated:&#160;</emphasis>
						<xsl:value-of select="@deprecated"/>
						<indexterm>
							<xsl:if test="$schema.index.type">
								<!-- Output a type attrib only if schema.index.type is set -->
								<xsl:attribute name="type"><xsl:value-of select="$schema.index.type"
									/></xsl:attribute>
							</xsl:if>
							<primary>Added in <xsl:value-of select="@deprecated"/></primary>
							<secondary localize="no"><xsl:value-of select="$table"/></secondary>
						</indexterm>
					</para>
				</xsl:when>
			</xsl:choose>
			<informaltable frame="all" pgwide="1">
				<xsl:processing-instruction name="bj"
					>custom-table-format</xsl:processing-instruction>
				<tgroup cols="3">
					<colspec colsep="1" colnum="1" colname="col0" colwidth="1.5em"/>
					<colspec colsep="1" colnum="2" colname="col1" colwidth="2.1in"/>
					<colspec colsep="1" colnum="3" colname="col2" colwidth="4.1in"/>
					<thead>
						<row rowsep="1" condition="print">
							<entry namest="col0" nameend="col2" align="center">
								<xsl:value-of select="@name"/>
							</entry>
						</row>
						<row rowsep="0">
							<entry colsep="1" rowsep="0" colname="col0" align="center">#</entry>
							<entry colsep="1" rowsep="0" colname="col1" align="center">Column
								name</entry>
							<entry colname="col2" rowsep="0" colsep="1" align="center"
								>Description</entry>
						</row>
					</thead>
					<tbody>
						<xsl:apply-templates select="bj:column"/>
					</tbody>
				</tgroup>
			</informaltable>
		</section>
		<xsl:processing-instruction name="bjfo">page-break</xsl:processing-instruction>
	</xsl:template>

	<xsl:template match="bj:column"> &do.not.edit; <row rowsep="1">
			<xsl:attribute name="xml:id"><xsl:value-of select="../@name"/>.<xsl:value-of
					select="@name"/></xsl:attribute> <entry colname="col0" valign="middle"
				align="center" colsep="1">
						<xsl:number value="position()"/>
						<!-- was 				<xsl:number value="position()" from="bj:table"/> -->
			</entry>
			<entry colname="col1" valign="top" colsep="1">
				<para>
					<database class="field"> <xsl:call-template name="string.subst">
							<xsl:with-param name="string" select="@name"/>
							<xsl:with-param name="target" select="'_'"/>
						</xsl:call-template> </database>
					<xsl:if test="./bj:format/@primaryKey">
						<xsl:text> (</xsl:text><glossterm linkend="primary.key.glossary"
							>PK</glossterm><xsl:text>) </xsl:text>
					</xsl:if>
					<!-- 		  <xsl:if  -->
					<!-- 			test="contains(@name, '_ID') and  -->
					<!-- 			substring-after(normalize-space(@name), '_ID') = ''"> -->
					<!-- 			<xsl:text> (</xsl:text><glossterm linkend="natural.key.glossary">NK</glossterm><xsl:text>)</xsl:text> -->
					<!-- 		  </xsl:if> -->
					<xsl:if test="./bj:format/@foreignKey">
						<xsl:text> (</xsl:text><glossterm linkend="foreign.key.glossary"
							>FK</glossterm><xsl:text>)</xsl:text>
					</xsl:if>
				</para>
				<xsl:choose>
					<xsl:when test="@added  and not(normalize-space(@added) = '')">
						<para>
							<emphasis role="bold">Added:&#160;</emphasis>
							<xsl:value-of select="@added"/>
							<indexterm>
								<xsl:if test="$schema.index.type">
									<!-- Output a type attrib only if schema.index.type is set -->
									<xsl:attribute name="type"><xsl:value-of
											select="$schema.index.type"/></xsl:attribute>
								</xsl:if>
								<primary>Added in <xsl:value-of select="@added"/></primary>
								<secondary localize="no"><xsl:value-of select="../@name"
									/></secondary>
								<tertiary localize="no"><xsl:value-of select="@name"/></tertiary>
							</indexterm>
						</para>
					</xsl:when>
					<xsl:when test="@removed">
						<para>
							<emphasis role="bold">Removed:</emphasis>
							<xsl:value-of select="@removed"/>
							<indexterm>
								<xsl:if test="$schema.index.type">
									<!-- Output a type attrib only if schema.index.type is set -->
									<xsl:attribute name="type"><xsl:value-of
											select="$schema.index.type"/></xsl:attribute>
								</xsl:if>
								<primary>Added in <xsl:value-of select="@removed"/></primary>
								<secondary localize="no"><xsl:value-of select="../@name"
									/></secondary>
								<tertiary localize="no"><xsl:value-of select="@name"/></tertiary>
							</indexterm>
						</para>
					</xsl:when>
					<xsl:when test="@deprecated">
						<para>
							<emphasis role="bold">Deprecated:</emphasis>
							<xsl:value-of select="@deprecated"/>
							<indexterm>
								<xsl:if test="$schema.index.type">
									<!-- Output a type attrib only if schema.index.type is set -->
									<xsl:attribute name="type"><xsl:value-of
											select="$schema.index.type"/></xsl:attribute>
								</xsl:if>
								<primary>Added in <xsl:value-of select="@deprecated"/></primary>
								<secondary localize="no"><xsl:value-of select="../@name"
									/></secondary>
								<tertiary localize="no"><xsl:value-of select="@name"/></tertiary>
							</indexterm>
						</para>
					</xsl:when>
				</xsl:choose> </entry>
			<entry colname="col2" valign="top" colsep="1">
				<xsl:choose>
					<xsl:when test="bj:descripton/text()">
						<para>
							<emphasis role="bold">Description: </emphasis>
							<xsl:apply-templates select="bj:description"/> <indexterm>
								<xsl:if test="$schema.index.type">
									<!-- Output a type attrib only if schema.index.type is set -->
									<xsl:attribute name="type"><xsl:value-of
											select="$schema.index.type"/></xsl:attribute>
								</xsl:if>
								<primary localize="no"><xsl:value-of select="../@name"/></primary>
								<secondary localize="no"><xsl:value-of select="@name"/></secondary>
							</indexterm>
							<indexterm>
								<xsl:if test="$schema.index.type">
									<!-- Output a type attrib only if schema.index.type is set -->
									<xsl:attribute name="type"><xsl:value-of
											select="$schema.index.type"/></xsl:attribute>
								</xsl:if>
								<primary localize="no"><xsl:value-of select="@name"/></primary>
								<secondary localize="no"><xsl:value-of select="../@name"
									/></secondary>
							</indexterm>
						</para>
					</xsl:when>
					<xsl:otherwise> <xsl:apply-templates select="bj:description"/> <indexterm>
							<xsl:if test="$schema.index.type">
								<!-- Output a type attrib only if schema.index.type is set -->
								<xsl:attribute name="type"><xsl:value-of select="$schema.index.type"
									/></xsl:attribute>
							</xsl:if>
							<primary localize="no"><xsl:value-of select="../@name"/></primary>
							<secondary localize="no"><xsl:value-of select="@name"/></secondary>
						</indexterm>
						<indexterm>
							<xsl:if test="$schema.index.type">
								<!-- Output a type attrib only if schema.index.type is set -->
								<xsl:attribute name="type"><xsl:value-of select="$schema.index.type"
									/></xsl:attribute>
							</xsl:if>
							<primary localize="no">
								<xsl:value-of select="@name"/>
							</primary>
							<secondary localize="no">
								<xsl:value-of select="../@name"/>
							</secondary>
						</indexterm>
					</xsl:otherwise>
				</xsl:choose>
				<!-- TODO: xsl:choose so that if there's no
		bj:example and there is a bj:constraint, you use the
		first bj:constraint as the example -->
				<xsl:choose>
					<!-- Uncomment the line below if you want to omit DATE examples. 
		  <xsl:when test="bj:format/@type = 'DATE'"/> -->
					<!-- Add an xsl:when here to catch other cases and generate specific example outputs. -->
					<xsl:when test="@name = 'PRODUCT_CLASS'">
						<para>
							<emphasis role="bold">Example: </emphasis>
							<literal>GlobeCom GT676</literal>
						</para>
					</xsl:when>
					<xsl:otherwise>
						<xsl:apply-templates select="bj:example"/>
					</xsl:otherwise>
				</xsl:choose> <xsl:apply-templates select="bj:constraints"/>
				<xsl:apply-templates select="bj:format"/>
				<xsl:apply-templates select="bj:source"/> </entry>
		</row>
	</xsl:template>

	<xsl:template match="bj:source">
		<para>
			<emphasis role="bold">Source: </emphasis>
			<xsl:copy-of select="./node()"/>
		</para>
	</xsl:template>

	<xsl:template match="bj:format">
		<para>
			<emphasis role="bold">Format: </emphasis>
			<literal>
				<xsl:choose>
					<xsl:when test="@type = 'LONG_VARCHAR'">
						<xsl:text>CLOB</xsl:text>
					</xsl:when>
					<xsl:when test="@type = 'LONG_RAW'">
						<xsl:text>BLOB</xsl:text>
					</xsl:when>
					<xsl:when test="@type= 'SMALL_INT'">
						<xsl:text>SMALL INT</xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="@type"/>
					</xsl:otherwise>
				</xsl:choose>
				<xsl:if test="@size and not(contains(@type,'&#40;'))">
					<xsl:text>(</xsl:text>
					<xsl:value-of select="@size"/>
					<xsl:text>)</xsl:text>
				</xsl:if>
				<xsl:text> </xsl:text>
				<xsl:if test="@nullable = 'false'">
					<xsl:text>NOT NULL</xsl:text>
				</xsl:if>
			</literal>
		</para>
	</xsl:template>

	<xsl:template match="bj:example">

		<xsl:choose>
			<xsl:when test="normalize-space(.) = '' or normalize-space(.) = 'FIXME'">
				<!-- Skip it -->
			</xsl:when>
			<xsl:when test="count(following-sibling::bj:constraints) &gt; 0">
				<!-- Skip it -->
			</xsl:when>
			<!-- 	  <xsl:when test="../@name = 'DM_CREATED_DATE' or ../@name = 'DM_UPDATED_DATE'"> -->
			<!-- 		<para>generic/auto-generated</para> -->
			<!-- 	  </xsl:when> -->
			
			
			<xsl:when test="./*">
				<!-- changed 8/27/13 test was 'not(normalize-space(text()))' but that gave error 'A sequence of more
					than one item is not allowed as the first argument of normalize-space in xsl 2.0 
				However, removing the normalize doesn't help. Ok, so:
				not(normalize-space(text())) is an attempt to say if you get nothing when you ask for text nodes and then normalize-space
					but it causes error
				not(*) doesnt' work, nor does not(text())...bad results
				
				not(normalize-space(string(text()))) has same sequence problem
				
				so then I changed it to "./*" to mean 'if there are any subelements',
				and that ...seems to work ok
				
				
				-->
				
				<!-- when there is markup in the example, copy it over as is... -->
				<para>
					<emphasis role="bold">Example: </emphasis>
					<xsl:comment>Detected markup in example, so copying over as-is.</xsl:comment>
  				    <xsl:copy-of select="node()"/>
				</para>
			</xsl:when>
			<xsl:otherwise>
				<para>
					<emphasis role="bold">Example: </emphasis>
					<xsl:comment>Detected NO markup in example, so wrapping in a literal.</xsl:comment>
					<literal><xsl:copy-of select="node()"/></literal>
				</para>
			</xsl:otherwise>
		</xsl:choose>

	</xsl:template>

	<xsl:template match="bj:constraints">
		<para>
			<emphasis role="bold">Constrained Values: </emphasis>
			<xsl:for-each select="bj:constraint">
				<literal>
					<xsl:value-of select="."/>
				</literal>
				<xsl:choose>
					<xsl:when
						test="count(following-sibling::bj:constraint) &gt; 1 or
			(count(following-sibling::bj:constraint) =   1 and
			count(preceding-sibling::bj:constraint) =   0)">
						<xsl:text>, </xsl:text>
					</xsl:when>
					<xsl:when
						test="count(following-sibling::bj:constraint) &gt; 0 and
			count(preceding-sibling::bj:constraint) &gt; 0">
						<xsl:text>, </xsl:text>
					</xsl:when>
					<xsl:otherwise>
						<xsl:text> </xsl:text>
					</xsl:otherwise>
				</xsl:choose>

			</xsl:for-each>
		</para>
	</xsl:template>

	<xsl:template match="bj:uks">
		<xsl:choose>
			<xsl:when test="count(bj:uk) &gt; 1">

				<para> The following columns taken together are unique: <xsl:for-each select="bj:uk">
						<database class="field">
							<xsl:value-of select="."/>
						</database>
						<!-- TODO: since you use this code more than once, you
			should probably make it a called template -->
						<xsl:choose>
							<xsl:when
								test="count(following-sibling::bj:uk) &gt; 1 or
				(count(following-sibling::bj:uk) =   1 and
				count(preceding-sibling::bj:uk) =   0)">
								<xsl:text>, </xsl:text>
							</xsl:when>
							<xsl:when
								test="count(following-sibling::bj:uk) &gt; 0 and
				count(preceding-sibling::bj:uk) &gt; 0">
								<xsl:text>, </xsl:text>
							</xsl:when>
							<xsl:otherwise>
								<xsl:text> </xsl:text>
							</xsl:otherwise>
						</xsl:choose>
					</xsl:for-each>
				</para>

			</xsl:when>
			<xsl:otherwise>
				<para> The <database class="field"><xsl:value-of select="bj:uk"/></database> column
					is unique. </para>
			</xsl:otherwise>
		</xsl:choose>

	</xsl:template>

	<xsl:template match="//bj:title"/>


	<!-- special case of description... 
	when the root element is part, we want to wrap the bj:subsystem/bj:description's content
	in a chapter tag, as you can't have bare para content in the front of a part.
	
	We also need a title, which I'm hardcoding here as 'Introduction'. If you don't like
	that, then you can OMIT the content of the bj:subsystem/bj:description, and instead include
	a <section> AFTER it, with whatever title you like; that will become a chapter in your
	part with the title you choose. Here I'm just trying to make sure we don't convert
	a datamodel into a form that makes invalid docbook.
	-->
	<xsl:template match="bj:subsystem/bj:description">
		<xsl:choose>
			<!-- when we're building a part, and the value of 
				bj:description is non-null ... -->
			<xsl:when test="normalize-space($schema.root.element) = 'part'
				and  normalize-space(.) !='' ">
				<chapter>
					<title>Introduction</title>
					<xsl:apply-templates/>
				</chapter>				
			</xsl:when>
			<xsl:otherwise>
				<xsl:apply-templates/>
			</xsl:otherwise>
		</xsl:choose>

	</xsl:template>

	<xsl:template match="bj:description">
		<xsl:choose>
			<!-- If it's a foreign key, then use boilerplate. If
      it's a foreign key and a primary key, add a sentence
      saying it's also a primary key. -->
			<xsl:when test="../bj:format/@foreignKey">
				<para>
					<emphasis role="bold">Description: </emphasis>A foreign key reference to the
						<database class="field"><link
							linkend="{substring-before(../bj:format/@foreignKey, '.')}.{substring-after(../bj:format/@foreignKey, '.')}"
								><xsl:value-of
								select="substring-after(../bj:format/@foreignKey, '.')"
						/></link></database> column in the <database class="table"><link
							linkend="{substring-before(../bj:format/@foreignKey, '.')}"
								><xsl:value-of
								select="substring-before(../bj:format/@foreignKey, '.')"
						/></link></database> table. <xsl:copy-of select="./*[1]/node()"/>
					<xsl:if test="../bj:format/@primaryKey"> Also serves as a primary key for this
						table.</xsl:if></para>
				<xsl:if test="not(normalize-space(.) = '')">
					<xsl:copy-of select="./*[position() &gt; 1]"/>
				</xsl:if>
			</xsl:when>
			<xsl:when test="../bj:format/@primaryKey">
				<para>
					<emphasis role="bold">Description: </emphasis>
					<xsl:choose>
						<!-- If it's a primary key and it's got a
			description of its own, use that.  -->
						<xsl:when test="not(normalize-space(./*[1]) = '')">
							<xsl:copy-of select="./*[1]/node()"/>
						</xsl:when>
						<xsl:when test="./share_para">
							<xsl:copy-of select="./share_para"/>
						</xsl:when>
						<!-- If it's a natural key, then put in a
			sentence saying it's a natural key and a
			primary key. -->
						<!-- 			<xsl:when test="contains(../@name, '_ID') and  -->
						<!-- 			  substring-after(normalize-space(../@name), '_ID') = ''"> -->
						<!-- 			  A natural key reference to a primary key in the -->
						<!-- 			  OLTP schema. Also serves as a primary -->
						<!-- 			  key in this table. -->
						<!-- 			</xsl:when> -->
						<!-- If it's a pk on a fact table, then it
			gets a special sentence. -->
						<xsl:when test="ancestor::bj:table[@type = 'fact']"> A
								<quote>warehouse</quote> key that is a primary key for the table and
							is generated using an Oracle <literal>SEQUENCE</literal> object. </xsl:when>
						<!-- Otherwise, it's a system generated
			primary key. -->
						<xsl:otherwise> System-generated primary key. </xsl:otherwise>
					</xsl:choose>
				</para>
				<xsl:if test="not(normalize-space(.) = '')">
					<xsl:copy-of select="./*[position()&gt;1]"/>
				</xsl:if>
			</xsl:when>
			<!-- 	  <xsl:when test="../@name = 'DM_UPDATED_DATE'"> -->
			<!-- 		<para> -->
			<!-- 		  <emphasis role="bold">Description: </emphasis> -->
			<!-- 		  Time stamp indicating when the record was last updated. -->
			<!-- 		</para> -->
			<!-- 	  </xsl:when> -->
			<!-- 	  <xsl:when test="../@name = 'DM_CREATED_DATE'"> -->
			<!-- 		<para> -->
			<!-- 		  <emphasis role="bold">Description: </emphasis> -->
			<!-- 		  Time stamp indicating when the record was created. -->
			<!-- 		</para> -->
			<!-- 	  </xsl:when> -->
			<!-- 	  <xsl:when test="contains(../@name, '_ID') and  -->
			<!-- 		substring-after(normalize-space(../@name), '_ID') = ''"> -->
			<!-- 		<para> -->
			<!-- 		  <emphasis role="bold">Description: </emphasis> -->
			<!-- 		  A natural key reference to a primary key in the -->
			<!-- 		  OLTP schema. -->
			<!-- 		</para> -->
			<!-- 		<xsl:if test="not(normalize-space(.) = '')"> -->
			<!-- 		  <xsl:copy-of select="./*"/> -->
			<!-- 		</xsl:if> -->
			<!-- 	  </xsl:when> -->
			<!--  Check to make sure that the description isn't
      empty for columns. Warn if not.  -->
			<xsl:when
				test="parent::bj:column and  
		normalize-space(.) = '' and 
		not(.//share_phrase)">
				<xsl:message> Danger Will Robinson! bj:description is empty for the field
						<xsl:value-of select="../../@name"/>.<xsl:value-of select="../@name"/>.
				</xsl:message>
			</xsl:when>

			<!-- JCBG-1956: Add FIXME if table has no description. -->
			<xsl:when 
				test="parent::bj:table and  
		normalize-space(.) = ''">
				<para>FIXME</para>
			</xsl:when>

			<!-- Otherwise, let it pass. -->
			<xsl:otherwise>
				<xsl:apply-templates/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>

	<xsl:template match="db:para[1][ancestor::bj:column]">
		<xsl:choose>
			<xsl:when test="normalize-space(.) = '' and not(./*)"/>
			<xsl:otherwise> &do.not.edit; <para>
					<emphasis role="bold">Description: </emphasis>
					<xsl:copy-of select="node()"/>
				</para>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>


	<xsl:template match="db:para"> &do.not.edit; <xsl:copy-of select="."/>
	</xsl:template>



	<xsl:template match="*[contains(local-name(.), 'share_') and substring-before(local-name(.), 'share_') = '']">
		<xsl:copy-of select="."/>
	</xsl:template>

	<xsl:template match="xi:include">
		<xsl:copy-of select="."/>
	</xsl:template>


	<xsl:template name="string.subst">
		<xsl:param name="string"/>
		<xsl:param name="target"/>

		<xsl:choose>
			<xsl:when test="contains($string, $target)">
				<xsl:value-of select="concat(substring-before($string,
		  $target), $target)"/>
				<xsl:processing-instruction name="sbr"/>
				<xsl:call-template name="string.subst">
					<xsl:with-param name="string" select="substring-after($string, $target)"/>
					<xsl:with-param name="target" select="$target"/>
				</xsl:call-template>
			</xsl:when>
			<xsl:otherwise>
				<xsl:value-of select="$string"/>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>




</xsl:stylesheet>
