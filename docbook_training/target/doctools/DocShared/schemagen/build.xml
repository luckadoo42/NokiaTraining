<?xml version="1.0" encoding="utf-8" standalone="no"?>


<project default="help">
  
  
  <!-- you need to have your target folder in place to run this thing successfully -->
  <import file="../main-build.xml"/> 

  <!-- property 'offline' = true if you want to skip sql downloads; defaults to false 
     the idea is that you would override this at the command line, like 
     ant merge -Doffline=true
     -->
  <property name="offline" value="false"/>

  <property name="xslpath" value="${doctools}\DocShared\schemagen\xsls"/>
  <property name="sqlpathname" value="${doctools}\DocShared\schemagen\sql\schema2datamodelraw.sql"/>
  <!-- set property schema.example.year to the 4-digit current year -->
  <tstamp>
    <format property="schema.example.year" pattern="yyyy" locale="en,US"/>
    <format property="datetime" pattern="MM/dd/yyyy hh:mm" locale="en,US"/>
  </tstamp>
  
  <property name="schema.rh.keyword" value="Database"/> <!-- JCBG-1869 setting a default value for this property -->

  <property name="schema.table.include" value="NONE"/> <!-- JCBG-1953 -->



<target name="help">
<echo> 
Edit your project's schema/build.properties file to set required properties for the schema reference, including the names of input files, the title of the reference, and whether it is built as  a chapter, appendix, or part.

Also see http://pubs/wiki/SchemaReferenceHowTo for more information about how this stuff works.
=========
Targets:
=========

help: Displays this message. 

test, or test-connection: Attempts a database connection using 
the same properties that will be used for a create or merge. 
Uses the following properties in your build.properties file to
connect to a database: 
schema.dbuser, schema.dbpw, schema.dbname
...if the test fails, check the values of those properties.
   'test' is just an alias for 'test-connection'

create: Connects to a database, downloads data, and creates a 
datamodel file from it. Typically, you do this only once, to 
create the initial datamodel file. After the initial file 
exists, you run a merge instead.

merge: Connects to a database, downloads data, and generates 
a file 'newdatamodel.xml'. Then compares that file with your 
existing datamodel file and merges data into the existing 
datamodel file. The merge lists out the changes it makes and
also writes that information to a text file, mergelog.txt.
   OPTION: use the property offline=true to skip the database
connection step and just do a merge using the current 
'newdatamodel.xml' file, for test purposes. For example 'ant merge -Doffline=true'

validate-datamodel, or val: Validates the datamodel file (using the file named as the value of datamodelbook-filename).

list-tables: Creates a text file, tables.txt, listing all the 
tables (and views) in the schema. Use this to edit the lookup table in 
datamodel2docbook.xsl that organizes the tables in to subsystems.

rebuild, or rebuild-schema-ref: These two names are equivalent.
'rebuild' converts the datamodel file (for this project, 
it's named ${datamodelbook-filename}) into a docbook file named 
${schema.ref.filename}, and copies the created file into 
the parent directory of /schema. ONLY TABLES THAT ARE LISTED 
IN YOUR categories.xsl file ARE INCLUDED IN THE 
${schema.ref.filename} file.

count-fixmes: Analyzes your datamodel file 
(${datamodelbook-filename})
and reports how many descriptions and examples are set at the 
default value of 'FIXME', indicating how many descriptions need
to be written. Also lists how many items are showing up as new, 
based on the current value of the 'new-version' property 
(which is currently set to ${new-version})

echoprops: Lists out all the properties that are defined when you
run targets in this build.xmls file, including properties defined 
in your build.properties file in your /schema folder.

whatsnew: Generates an xml file listing changes like new tables and new columns, based on the schema.whatsnew.version property. 

</echo>
</target>


<target name="copycat"><!-- utility target, used whenever we need to copy the categories file -->

  <echo>Copying local category file (categories.xsl) to target folder.</echo>

  <!-- Copy the project's categories.xsl file into the schemagen/xsls dir, because we need to reference it in datamodel2docbook.xsl, but we can't use a param for the path, because include and import statements happen at compile time.

Now this is in its own target, to be used by more than one target.

  -->

    <copy overwrite="true" verbose="true" file="categories.xsl" todir="${xslpath}"/>
</target>

<!-- alias for rebuild-schema-ref, shorter form...-->
<target name="rebuild" depends="rebuild-schema-ref"/>

  <target name="rebuild-schema-ref" depends="validate-datamodel,copycat">

	<echo>Starting schema-ref rebuild...</echo>
    

<!-- First we refresh the db reference. Notice that we're generating it in schema/schema-ref.xml first. -->
	
<!-- I could have used the saxon6-xslt macro from main-build.xml for this, but on the other hand it has a ton of properties set that I don't need. -->

<echo>
Now converting the datamodel file (${datamodelbook-filename}) to a schema reference file (${schema.ref.filename})

</echo>

<sequential>


  <saxon-xslt 
	  in="${datamodelbook-filename}" 
      out="${schema.ref.filename}" 
      style="${xslpath}/datamodel2docbook.xsl"   
      force="true">
      <param name="schema.root.element" expression="${schema.root.element}"/>
      <param name="schema.id" expression="${schema.id}"/>
      <param name="schema.index.type" expression="${schema.index.type}"/>
      <param name="schema.rh.keyword" expression="${schema.rh.keyword}"/>
      <param name="schema.table.include" expression="${schema.table.include}"/> <!-- JCBG-1953 -->
   </saxon-xslt> 


<!-- before we changed to xslt 2.0 for this, we used:
  <xslt
      classpath="${saxon6}"
      in="${datamodelbook-filename}" 
      out="${schema.ref.filename}" 
      style="${xslpath}/datamodel2docbook.xsl"   
      force="true">
      <param name="schema.root.element" expression="${schema.root.element}"/>
      <param name="schema.subelement" expression="${schema.subelement}"/>
      <param name="schema.id" expression="${schema.id}"/>
      <param name="schema.index.type" expression="${schema.index.type}"/>
      <factory name="com.icl.saxon.TransformerFactoryImpl"/>
    </xslt> -->
</sequential>           

    <!-- A lazy way to remove namespace cruft from db reference -->
    
    <replace encoding="utf-8" file="${schema.ref.filename}" token='xmlns:db="http://docbook.org/ns/docbook"' value=""/>
    <replace encoding="utf-8" file="${schema.ref.filename}" token='xmlns:bj="http://motive.com/techpubs/datamodel"' value=""/>
    
	

	<!-- Ok, if the above succeed, we move the schema ref up a dir -->

   <move file="${schema.ref.filename}" tofile="../${schema.ref.filename}"/>

  </target>

<target name="create">

<!-- Run an SQL script to create a datamodel file from a database connection.

Prerequisite: 
  - install Oracle driver.
  - set properties schema.dbuser, schema.dbpw, schema.dbname, datamodelbook-filename, schema.ref.title

-->

  <echo>Connecting to Oracle using command 'sqlplus ${schema.dbuser}/${schema.dbpw}@${schema.dbname} @${sqlpathname} ${datamodelbook-filename}</echo>

  <exec executable="sqlplus">
    <arg value="${schema.dbuser}/${schema.dbpw}@${schema.dbname}"/>
    <arg value="@${sqlpathname}"/>
    <arg value="${datamodelbook-filename}"/> <!-- passing script: filename to spool to -->
   </exec>

  <!-- Insert schema ref title in generated file -->
  <replace file="${datamodelbook-filename}" token="@@schema.ref.title@@" value="${schema.ref.title}"/> 
  <!-- Insert schema example year in generated file 
	   The year property was set earlier in this file by a timestamp command
	-->
  <replace file="${datamodelbook-filename}" token="@@schema.example.year@@" value="${schema.example.year}"/> 
</target>

   <!-- alias for test-connection; shorter form -->
  <target name="test" depends="test-connection"/> 

  <!-- Test the database connection using the properties configured in build.properties; JCBG-665 -->
  <target name="test-connection">

  <echo>=========================
Testing database connection

Connecting to Oracle using command 'sqlplus ${schema.dbuser}/${schema.dbpw}@${schema.dbname}</echo>

   <exec executable="sqlplus">
    <arg value="${schema.dbuser}/${schema.dbpw}@${schema.dbname}"/>
   </exec>
  <echo>=========================</echo>

</target>


  <target name="merge" depends="copycat">

    <!-- First, get latest SQL data and write out as 'newdatamodel.xml'; this is just like
		 doing a 'create', but we write the result to a different file. 
		 
		 Note that the former merge (now called merge-erwin) used a different filename, newdatamodel-book.xml...

    -->
  <if>  
    <equals arg1="${offline}" arg2="false"/>
    <then>
       <echo>Connecting to Oracle using command 'sqlplus ${schema.dbuser}/${schema.dbpw}@${schema.dbname} @${sqlpathname} newdatamodel.xml</echo>
       <exec executable="sqlplus">
         <arg value="${schema.dbuser}/${schema.dbpw}@${schema.dbname}"/>
         <arg value="@${sqlpathname}"/>
         <arg value="newdatamodel.xml"/> <!-- passing script: filename to spool to -->
       </exec>
    </then>
    <else>
    <echo>Skipping database data download because offline=true. Skipping attempt to connect to Oracle using command 'sqlplus ${schema.dbuser}/${schema.dbpw}@${schema.dbname} @${sqlpathname} newdatamodel.xml</echo>
    </else>
  </if>


   <!-- Insert schema ref title in generated file
		We're doing this here because suppose you changed your schema.ref.title; this updates it in the new file, and then we'll use that during the merge
    -->
  <replace file="newdatamodel.xml" token="@@schema.ref.title@@" value="${schema.ref.title}"/> 
  <!-- Insert schema example year in generated file 
	   The year property was set earlier in this file by a timestamp command
	-->
  <replace file="newdatamodel.xml" token="@@schema.example.year@@" value="${schema.example.year}"/> 



    <!-- next use merge.xsl to combine old and new.

I'm using some properties from main-build.xml, so I had to add a line to import that file. 



-->

<!-- start writing to file 
  added new-version property to output 8/17/15 for JCBG-1716
-->
<record name="mergelog.txt" append = "yes" action="start"/>

<echo>=======================
Merge log
=======================
old-doc =  ${input_file_path}/${datamodelbook-filename}
new data is in newdatamodel.xml

Merge run at ${datetime}, using new version property ${new-version}.

Merge process will merge data into the old doc, and archive a copy of the old doc under a timestamped name.
=======================</echo>

<!-- 8/27/13...changing to saxon-xslt to run the XSL -->
    <sequential>
         <saxon-xslt in="newdatamodel.xml" 
					 out="${datamodelbook-filename}-merged"
					 style="${xslpath}/merge.xsl" 
					 force="true">
           <param name="old-doc" expression="../../../../../${input.file.path.trimmed}/${datamodelbook-filename}"/>
           <param name="new-version" expression="${new-version}"/>
		   <param name="verbose" expression="${schema.verbose}"/>
        </saxon-xslt>
    </sequential>

    <record name="mergelog.txt" action="stop"/>

    <!-- then set time properties -->
    <tstamp/>

    <!-- make a time-tagged backup -->
    <copy file="${datamodelbook-filename}"
      tofile="${datamodelbook-filename}-${DSTAMP}-${TSTAMP}-bak"/>

    <move file="${datamodelbook-filename}-merged" tofile="${datamodelbook-filename}"/>

  </target>





  <target name="create-erwin">

    <!-- This target runs one xsl against the xml data file to create a datamodelbook file -->

    <xslt in="${erwin-file}" out="${datamodelbook-filename}" style="${xslpath}/erwin2datamodel.xsl"
      force="true">

     <param name="schema.ref.title" expression="${schema.ref.title}"/>
    </xslt>


  </target>



  <target name="merge-erwin">

    <!-- First, transform erwin file to datamodel in a file named 'new-data-dbk'-->

    <xslt in="${erwin-file}" out="newdatamodelbook.xml" style="${xslpath}/erwin2datamodel.xsl" force="true">
       <param name="schema.ref.title" expression="${schema.ref.title}"/>
    </xslt>

    <!-- next use merge.xsl to combine old and new.

I'm using some properties from main-build.xml, so I had to add a line to import that file. 
Also, merge.xsl did not work when using the standard xslt...
I had to use the classpath and factory values shown below, which come from main-build's saxon6-xslt macro...to make it use saxon.


-->

<echo> old-doc =  ${input_file_path}/${datamodelbook-filename}</echo>

    <sequential>
      <xslt classpath="${saxon6}" in="newdatamodelbook.xml" out="${datamodelbook-filename}-merged"
        style="${xslpath}/merge.xsl" force="true">
        <factory name="com.icl.saxon.TransformerFactoryImpl"/>
        <param name="old-doc" expression="${input_file_path}/${datamodelbook-filename}"/>
        <param name="new-version" expression="${new-version}"/>
      </xslt>
    </sequential>

    <!-- then set time properties -->
    <tstamp/>

    <!-- make a time-tagged backup -->
    <copy file="${datamodelbook-filename}"
      tofile="${datamodelbook-filename}-${DSTAMP}-${TSTAMP}-bak"/>

    <move file="${datamodelbook-filename}-merged" tofile="${datamodelbook-filename}"/>

  </target>



  <target name="diagram">
    <echo> Converting ${datamodelbook-filename} to an ER diagram in SVG form.
THIS IS NOT DONE YET.
</echo>
    
    <xslt in="${datamodelbook-filename}" out="datamodel.svg" style="${xslpath}/datamodel2svg.xsl" force="true"/>
 
  </target>


  <target name="list-tables">

    <echo> Creating a list of the tables and views that are in ${datamodelbook-filename}.</echo>

    <xslt in="${datamodelbook-filename}" out="tables.txt" style="${xslpath}/tablelist.xsl" force="true"/>

    <concat>
       <fileset dir="." includes="tables.txt"/>
    </concat>

    <echo> Results saved to tables.txt. </echo>

  </target>


  <target name="count-fixmes">

  <xslt in="${datamodelbook-filename}" out="fixmes.txt" style="${xslpath}/count-fixmes.xsl" force="true">
    <param name="new-version" expression="${new-version}"/>
  </xslt>

    <concat>
       <fileset dir="." includes="fixmes.txt"/>
    </concat>

    <echo> Results saved to fixmes.txt. </echo>

  </target>

  <target name="val" depends="validate-datamodel"/> <!-- shortcut for the below-->

  <!-- adding target to validate datamodel per JCBG-1958-->
    <target name="validate-datamodel" depends="jingtask">
        <jing rngfile="${doctools}/DocShared/schemas/broadbook/datamodel.rng" file="${datamodelbook-filename}"
            checkid="false"/>
    </target>

<!-- default props for whatsnew -->
<property name="schema.whatsnew.id" value="schema.whatsnew.topic"/>
<property name="schema.whatsnew.filename" value="schema.whatsnew.topic.xml"/>
<property name="schema.whatsnew.version" value="VERSION-NOT-SET"/>
<property name="schema.whatsnew.title" value="New in ${schema.whatsnew.version}"/>



<target name="whatsnew" depends="copycat"> <!-- generate what's new topic -->


  <saxon-xslt in="${datamodelbook-filename}" 
      out="${schema.whatsnew.filename}" 
      style="${xslpath}/whatsnew.xsl"   
      force="true">
    <param name="schema.whatsnew.id" expression="${schema.whatsnew.id}"/>
    <param name="schema.whatsnew.version" expression="${schema.whatsnew.version}"/>
    <param name="schema.whatsnew.title" expression="${schema.whatsnew.title}"/>
  </saxon-xslt>

   <!-- copy the generated file up a dir level --> 
   <copy file="${schema.whatsnew.filename}" todir=".." />

   
   
    </target>

  
</project>
